# Space RP Game World Generator v3
# Starts by generating random systems with stellar map coordinates, if the system is habitable or not, if the system has a habitable planet with cities, a starbase, an asteroid base, or a base on an uninhabitable planet

Import-Module AWSPowershell

Add-Type -AssemblyName System.Drawing

# Get the home directory for the script
$homePath = "G:\Colonial_Alliance_Game"

# Set the locations of required software and filepaths for the script to operate
$WorldScriptPath = "$homePath\game-world-generator\powershell-version\generate-game-world"
$SoftwarePath = "$homePath\StarmapCreation\Software"
$htmlFiles = "$SoftwarePath\StarGen\html"
$stargenPath = "$SoftwarePath\StarGen\StarGen.exe"
$planetgenPath = "$SoftwarePath\Planets\planet.exe"
$systemsPath = "$homePath\StarmapCreation\StarSystems"
$refFilesDir = "$SoftwarePath\StarGen\ref"

# Reset the world generation. Deletes all systems created
$doGeneration = $true

# Define the main starmap properties
$systemCount = 90 # star systems per map (sector) # Standard 5000
$systemCountVariation = 15 # how much to randomly vary the number or and down from system count
$sectorNumber = "2" # What sector of space is this, purely for labelling the map
$gridDividers = 12 # How many grid lines to have on the map
$gridDividerPixels = 100 # How many pixels between each grid line
$buffer = 5 # Pixel buffer around the edges of the map image

# Kanka details
$uploadToKanka = $true
$kankaCampaignURL = "https://kanka.io/api/1.0/campaigns/111078"
$kankaPANPath = "$homePath\kankaPANKey.txt"

# AWS details
$uploadToAWS = $true
$bucketName = "rpg-objects"
$awsProfileName = "rpg-stuff-profile"

################ END OF CUSTOMISABLE VARIABLES ################

$kankaPANkey = Get-Content $kankaPANPath

if (!(Test-Path $WorldScriptPath)) {Write-Host "generate-game-world folder not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $SoftwarePath)) {Write-Host "Software folder not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $htmlFiles)) {Write-Host "StarGen HTML folder not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $stargenPath)) {Write-Host "StarGen executable not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $planetgenPath)) {Write-Host "Planet Generator executable not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $systemsPath)) {Write-Host "Location where to output created star systems files not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $refFilesDir)) {Write-Host "reference files StarGen uses in its HTML files not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if ($uploadToKanka -eq $true -and $kankaCampaignURL -eq "") {Write-Host "Kanka campaign URL missing" -BackgroundColor Red -ErrorAction Stop}
if ($uploadToAWS -eq $true -and $bucketName -eq "") {Write-Host "S3 Bucket name missing" -BackgroundColor Red -ErrorAction Stop}

# colour values for the biomes where we can put settlements created on the planet maps generated by planet.exe
$okBiomes = "210210210","250215165","105155120","220195175","225155100","155215170","170195200","185150160","130190025","110160170"# Tundra, Grasslands, Taiga, Desert, Savanna, Temperate Forest, Temperate Rainforest, Xeric Shrubland and Dry Forest, Tropical Dry Forest, Tropical Rainforest

# Names to use when naming star systems which are claimed
[System.Collections.ArrayList]$systemNames = "Nexus,Neotopia,Aeloria,Aetheria,Albion,Alexandria,Amaterasu,Amsterdam,Andromeda,Angkor,Antares,Araucaria,Arcadia,Artemis,Asgard,Athens,Atlantis,Aurielle,Avalon,Azurite,
                                                Babylon,Bali,Bangkok,Barcelona,Beijing,Berlin,Bharat,Brittanica,Byzantium,Caelum,Cairo,Calypso,Camelot,Caprica,Carthage,Casablanca,Caspia,Ceres,Ceylon,Chandra,Chichen Itza,
                                                Chimera,Chiron,Colossus,Copenhagen,Cordoba,Cyberion,Dalarna,Dantooine,Delphi,Dravida,Dubai,Dublin,Echelon,Edenia,Edinburgh,El Dorado,Elysium,Eridanus,Esperia,Euphoria,
                                                Galaxia,Gilead,Gilead,Hades,Halcyon,Hanoi,Helios,Helsinki,Hiroshima,Hy Brasil,Hyperborea,Hyperion,Icaria,Inca,Isfahan,Isla Nublar,Istanbul,Jakarta,Jerusalem,Jovia,Kaida,
                                                Kemet,Kepler,Krynn,Krypton,Kuala Lumpur,Kyoto,Lemuria,London,Los Angeles,Lumina,Luminar,Luminelle,Machu Picchu,Magellan,Mahabharata,Manila,Melbourne,Meridian,Mjolnir,
                                                Moscow,Mumbai,Mumbai,Nagasaki,Narnia,Neo-Tokyo,Neuheim,New York,Nibiru,Nirvana,Novamira,Oberon,Odyssey,Olympus,Omicron,Orinoco,Orion,Osaka,Oslo,Oz,Pandemonium,Pandora,
                                                Pangea,Paris,Penglai,Persepolis,Perseus,Petra,Phnom Penh,Phoenix,Polaris,Pompeii,Prometheus,Pythia,Rapa Nui,Regalia,Rhapsody,Rigel,Rio de Janeiro,Rome,Sagittarius,Sakurano,
                                                Samarkand,Seoul,Serenity,Shambhala,Shanghai,Shangri-La,Singapore,Siren,Solitude,Solstice,Sputnik,Stardust,Stockholm,Stratos,Sydney,Tabriz,Taipei,Talaria,Tartarus,Tel Aviv,
                                                Terra Nova,Tesseract,Thalassa,Themyscira,Thule,Tikal,Titan,Tokyo,Transcendence,Utopia,Valhalla,Vega,Vesperia,Vienna,Vulcan,Wakanda,Xanadu,Xenon,Yggdrasil,Zhulong,Zion,Zora,
                                                Nova Aurora,Terra Prime,Arcadia,Stardust Haven,Celestia,Horizon Reach,Nebula Outpost,Solaris Colony,Andromeda Station,Lunar Nexus,Nexus Prime,Elysium Settlement,Orion's Haven,
                                                Cosmo Frontier,Serenity Point,Stellaris Enclave,Galactica Outpost,Nova Gaia,Solara Habitat,Saturnia Outpost,Hyperion Station,Zenith City,Pandora Colony,Phobos Outpost,
                                                Apollo Landing,Astral Dominion,Terra Nova,Centauri Colony,Astoria Station,Vortex Encampment,Atlantis Outpost,Nebulus Outpost,Nova Prime,Stardust Outpost,Aetheria Habitat,
                                                Lunaris Settlement,Equinox Encampment,Utopia Station,Cosmo Haven,Seraphim Enclave,Celestial Nexus,Genesis Colony,Nebula Nexus,Epsilon Outpost,Lunar Haven,Artemis Settlement,
                                                Vega Enclave,Pegasus Station,Zenith Colony,Pandora Haven,Phoenix Outpost,Cosmos Encampment,Alpha Prime,Solaris Encampment,Astralis Outpost,Terra Haven,Astra Enclosure,
                                                Orion's Reach,New Eden,Novus Terra,Horizon Colony,Lyra Outpost,Aurora Station,Lunaris Enclave,Hyperion Colony,Stardust Nexus,Apollo Outpost,Serenity Settlement,Nebula Haven,
                                                Elysium Encampment,Titan Station,Celestis Outpost,Nova Encampment,Zenith Haven,Pandora Enclave,Artemis Outpost,Solaris Settlement,Nova Terra,Genesis Outpost,Astra Nexus,Astralis Haven,
                                                Phoenix Enclave,Alpha Outpost,Lunaris Colony,Nova Haven,Orion's Nexus,Elysium Station,Solara Outpost,Nebula Enclosure,Lyra Colony,Horizon Encampment,Stardust Settlement,Terra Enclave,
                                                Apollo Colony,Celestia Station,Pandora Encampment,Nova Nexus,Serenity Outpost,Zenith Enclave,Astra Outpost" -split ','
[int]$masterMapSizeX = $gridDividers*$gridDividerPixels+2 # map file pixel width
[int]$masterMapSizeY = $masterMapSizeX # map file pixel heigh
$masterMapBmp = new-object System.Drawing.Bitmap $masterMapSizeX,$masterMapSizeY
$masterMapBrushBg = [System.Drawing.Brushes]::Black
$fontMapNum = new-object System.Drawing.Font "Lucida Sans",8
$fontStarNum = new-object System.Drawing.Font "Lucida Sans",7
$masterMapGraphics = [System.Drawing.Graphics]::FromImage($masterMapBmp)
$masterMapGraphics.FillRectangle($masterMapBrushBg,0,0,$masterMapBmp.Width,$masterMapBmp.Height)
$masterMapBrushTitle = [System.Drawing.Brushes]::White
$masterMapFileName = "Sector_$sectorNumber`_Starmap.jpg"

# Gets AWS credentials
$awsCreds = Get-AWSCredential -ProfileName $awsProfileName

# Uploading StarGen reference files to the bucket
if ($uploadToAWS) {
    $refFiles = Get-ChildItem $refFilesDir/*
    $refCheck = ((Get-S3Object -BucketName "$bucketName" -Credential $awsCreds | where {$_.Key -match "ref"}).count) -ge 0
    if (!$refCheck) {
        foreach ($refFile in $refFiles) {
            $refFilePath = Join-Path $refFile.Directory $refFile.Name
            $refFilePath
            Write-S3Object -BucketName "$bucketName/ref" -Credential $awsCreds -PublicReadOnly -File $refFilePath
        }
    }
}

# Clears all the world data created
if ($doGeneration) {
    Remove-Item -Path "$systemsPath\*" -Recurse -Force
    Remove-Item -Path "$htmlFiles\*" -Recurse -Force
    Copy-Item -Path $refFilesDir -Destination $systemsPath -Recurse
    Get-S3Object -BucketName "$bucketName" -Credential $awsCreds | where {$_.Key -notmatch "ref"} | Remove-S3Object -Credential $awsCreds -Force
    $kankaMapEntityID = ((Invoke-RestMethod -Uri "$kankaCampaignURL/entities" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data  | where {$_.name -match "$sectorName"}).id
    Invoke-RestMethod -Uri "$kankaCampaignURL/entities/$kankaMapEntityID/image" -Method DELETE -Headers @{'Authorization'="Bearer $kankaPANkey"} -UseBasicParsing -ContentType "application/json"
    $kankaMapID = ((Invoke-RestMethod -Uri "$kankaCampaignURL/maps" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data  | where {$_.name -match "$sectorName"}).id
    Invoke-RestMethod -Uri "$kankaCampaignURL/maps/$kankaMapID" -Method DELETE -Headers @{'Authorization'="Bearer $kankaPANkey"} -UseBasicParsing -ContentType "application/json"
    $kankaLocationIDs = (Invoke-RestMethod -Uri "$kankaCampaignURL/locations" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data.id
    foreach ($locationID in $kankaLocationIDs) {
        Invoke-RestMethod -Uri "$kankaCampaignURL/locations/$locationID" -Method DELETE -Headers $headers -UseBasicParsing -ContentType "application/json"
    }
}

# Attempts to represent reasonably accurate real world chances of star type, they're in order of star colour, lower mass range, upper mass range, chance of planets, chance of habitable planets.
function Get-StarType {
    $rnd = Get-Random -Minimum 1 -Maximum 1000000
    switch ($rnd) {
        {$_ -ge 1 -and $_ -le 3} {"Blue",$(Get-Random -Minimum 3 -Maximum 150),0,0}
        {$_ -ge 4 -and $_ -le 1400} {"LightSkyBlue",3,70,0,0}
        {$_ -ge 1401 -and $_ -le 7700} {"White",0.15,1.2,0,0}
        {$_ -ge 7701 -and $_ -le 29000} {"LightYellow",0.9,1.2,80,5}
        {$_ -ge 29001 -and $_ -le 106000} {"Yellow",0.9,1.2,95,40}
        {$_ -ge 106001 -and $_ -le 235500} {"Orange",0.5,0.8,80,0}
        {$_ -ge 235501 -and $_ -le 1000000} {"Red",0.075,0.4,70,0}
    }
}

function Get-StarLocation {
    $labelX = 0..140
    $labelY = 0..48
    do {
        $1 = Get-Random -Minimum 5 -Maximum ($masterMapSizeX-5)
        $2 = Get-Random -Minimum 5 -Maximum ($masterMapSizeY-5)
        $coords = "$1,$2"
    } until ($systemsCoordArray -notcontains $coords -and ($1 -notin $labelX -or $2 -notin $labelY))
    $systemsCoordArray += "$1,$2"
    return $coords
}

function New-PlanetaryUninhabitableSystem {
param($StarMass,$StarName)
Set-Location ($stargenPath | Split-Path)
    do {
        Start-Process $stargenPath -ArgumentList "-m$StarMass -M -g" -Wait -NoNewWindow
        Start-Sleep -Seconds 1
        $starFile = (Get-ChildItem $htmlFiles -Filter "*.html").FullName | Sort-Object -Property LastWriteTime | Select-Object -Last 1
        $starFileTerresCheck = (Get-Content $starFile -Raw) -match "Terrestrial"
        if ($starFileTerresCheck -eq $true) {
            Remove-Item "$htmlFiles\*" -Force
        }
    } until ($starFile -ne $null -and $starFileTerresCheck -eq $false)
    $html = Get-Content $starFile -Raw
    $htmlWeb = Invoke-WebRequest -Uri $starfile -UseBasicParsing
    $asteroidBool = ($html | Select-String -Pattern "Asteroids.gif" -AllMatches).matches.count -ge 1
    $currentSeed = (($html -split "`n" | Select-String -Pattern "System *") -split ">" -split "-" -split " " -split "<")[3]
    $currentName = "System $currentSeed - StarGen.exe $currentSeed-$StarMass"
    $currentFileLink = "StarGen.exe $currentSeed-$StarMass"
    $currentFileName = "StarGen.exe-$currentSeed-$StarMass"
    $html = $html -replace $currentName,$StarName
    $html = $html -replace $currentFileName,$StarName
    $html = $html -replace $currentFileLink,$StarName
    $htmlObj = New-Object -Com "HTMLFile"
    $htmlObj.IHTMLDocument2_write($htmlWeb.RawContent)
    Set-Content "$htmlFiles\$StarName.html" $html
    New-Item -Path $systemsPath -ItemType Directory -Name $StarName
    Move-Item -Path "$htmlFiles\$StarName.html" -Destination $systemsPath\$StarName
    if ($uploadToAWS) {
        Write-Host "Writing $systemsPath\$StarName\$StarName.html to S3"
        Write-S3Object -BucketName "$bucketName/$StarName" -Credential $awsCreds -File "$systemsPath\$StarName\$StarName.html" -PublicReadOnly
    }
    return $asteroidBool
}

function New-HabitableSystem {
param($StarMass,$StarName)
Set-Location ($stargenPath | Split-Path)
    do {
        Start-Process $stargenPath -ArgumentList "-m$StarMass -M -g" -Wait -NoNewWindow
        Start-Sleep -Seconds 1
        $starFile = (Get-ChildItem $htmlFiles -Filter "*.html").FullName | Sort-Object -Property LastWriteTime | Select-Object -Last 1
        $starFileTerresCheck = (Get-Content $starFile -Raw) -match "Terrestrial"
        if ($starFileTerresCheck -ne $true) {
            Remove-Item "$htmlFiles\*" -Force
        }
    } until ($null -ne $starFile -and $starFileTerresCheck -eq $true)
    $html = Get-Content $starFile -Raw
    $htmlWeb = Invoke-WebRequest -Uri $starfile -UseBasicParsing
    $hydrospheres = @(($html -split "`n" | Select-String -Pattern "Hydrosphere") -replace "<TR>","" -replace "<TH>","" -replace "</TR>","" -replace "</TH>","" -replace "<TD>","" -replace "</TD>","" -replace "Hydrosphere percentage","" | where {$_ -notmatch "0.0"}) -split "`n"
    $terresCount = ($html -split "<" | Select-String -Pattern "TerrestrialPlanet.gif" | Group-Object).count
    $asteroidBool = ($html | Select-String -Pattern "Asteroids.gif" -AllMatches).matches.count -ge 1
    $currentSeed = (($html -split "`n" | Select-String -Pattern "System *") -split ">" -split "-" -split " " -split "<")[3]
    $currentName = "System $currentSeed - StarGen.exe $currentSeed-$StarMass"
    $currentFileLink = "StarGen.exe $currentSeed-$StarMass"
    $currentFileName = "StarGen.exe-$currentSeed-$StarMass"
    $html = $html -replace $currentName,$StarName
    $html = $html -replace $currentFileName,$StarName
    $html = $html -replace $currentFileLink,$StarName
    $htmlObj = New-Object -Com "HTMLFile"
    $htmlObj.IHTMLDocument2_write($htmlWeb.RawContent)
    Set-Content "$htmlFiles\$StarName.html" $html
    New-Item -Path $systemsPath -ItemType Directory -Name $StarName
    Move-Item -Path "$htmlFiles\$StarName.html" -Destination $systemsPath\$StarName
    if ($uploadToAWS) {
        Write-Host "Writing $systemsPath\$StarName\$StarName.html to S3"
        Write-S3Object -BucketName "$bucketName/$StarName" -Credential $awsCreds -File "$systemsPath\$StarName\$StarName.html" -PublicReadOnly
    }
    return $asteroidBool,$terresCount,$hydrospheres
}

Function New-NonPlanetarySystem {
param($systemLabel,$systemDesignation,$xcoord,$ycoord,$starType,$starMass,$planetBool,$habitableBool)
    $asteroidFieldBool = (Get-Random -Minimum 0 -Maximum 100) -in 0..12
    $html = @"
    <!DOCTYPE html>
        <html>
        <head>
            <title>System Information</title>
            <style>
            table {
                border-collapse: collapse;
            }
            th, td {
                border: 1px solid black;
                padding: 8px;
            }
            </style>
        </head>
        <body>
            <h1>System Information</h1>
            <table>
            <tr>
                <th>System Name</th>
                <th>System Designation</th>
                <th>X Coordinate</th>
                <th>Y Coordinate</th>
                <th>Star Colour</th>
                <th>Star Mass</th>
                <th>Has Planets</th>
                <th>Habitable</th>
                <th>AsteroidField</th>
            </tr>
            <tr>
                <td>$systemLabel</td>
                <td>$systemDesignation</td>
                <td>$((($systemCoords) -split ",")[0])</td>
                <td>$((($systemCoords) -split ",")[1])</td>
                <td>$($starType[0])</td>
                <td>$starMass</td>
                <td>$planetBool</td>
                <td>$habitableBool</td>
                <td>$($asteroidFieldBool[0])</td>
            </tr>
            </table>
        </body>
        </html>
"@
    New-Item -ItemType Directory -Path $systemsPath -Name $systemLabel
    $html | Out-File "$systemsPath\$systemLabel\$systemLabel.html"
    if ($uploadToAWS) {
        Write-Host "Writing $systemsPath\$systemLabel\$systemLabel.html to S3"
        Write-S3Object -BucketName "$bucketName/$systemLabel" -Credential $awsCreds -File "$systemsPath\$systemLabel\$systemLabel.html" -PublicReadOnly
    }
    return $asteroidFieldBool
}

# Generate star system base values
$systemsCoordArray = @()
$systemsArray = New-Object System.Collections.Generic.List[psobject]

if ($doGeneration) {
    $systemCountFinal = Get-Random -Minimum ($systemCount-$systemCountVariation) -Maximum ($systemCount+$systemCountVariation)
    foreach ($systemCount in 1..$systemCountFinal) {
        $starType = Get-StarType
        do {
            $systemCoords = Get-StarLocation
            if ($systemsCoordArray -contains $systemCoords) {
                Write-Host "Duplicate coordinates found, retrying" -BackgroundColor Red
            }
        } until ($systemsCoordArray -notcontains $systemCoords)
        $systemsCoordArray += "$systemCoords"
        [string]$systemNum = $($systemCoords) -replace ","
        $systemDesignation = ($sectorNumber+"_"+('{0:d4}' -f $systemCount))
        $starMass = Get-Random -Minimum $starType[1] -Maximum $starType[2]
        $planetBool = ((Get-Random -Minimum 0 -Maximum 100) -in 0..($starType[3]))
        if ($planetBool) {$habitableBool = ((Get-Random -Minimum 0 -Maximum 100) -in 0..($starType[4]))} else {$habitableBool = $false}
        if ($habitableBool -eq $True) {
            $systemLabel = (Get-Random -InputObject $systemNames)
            $systemNames.Remove($systemLabel)
        } else {
            $systemLabel = $sectorNumber+"_"+('{0:d4}' -f $systemCount)
        }
        if (!$planetBool) {
            Write-Host "Generating non-planetary system $systemLabel with stellar mass of $starMass"
            $nonPlanetaryReturn = New-NonPlanetarySystem -systemLabel $systemLabel -systemDesignation $systemDesignation -xcoord (($systemCoords) -split ",")[0] -ycoord (($systemCoords) -split ",")[1] -starType $($starType[0]) -starMass $starMass -planetBool $planetBool -habitableBool $habitableBool
        }
        if ($planetBool -eq $true -and $habitableBool -eq $true) {
            Write-Host "Generating inhabitable system $systemLabel with stellar mass of $starMass"
            $inhabitablePlanetReturn = New-HabitableSystem -StarMass $starMass -StarName $systemLabel
            $asteroidFieldBool = $inhabitablePlanetReturn[0]
        }
        if ($planetBool -eq $true -and $habitableBool -eq $false) {
            Write-Host "Generating uninhabitable system $systemLabel with stellar mass of $starMass"
            $asteroidFieldBool = New-PlanetaryUninhabitableSystem -StarMass $starMass -StarName $systemLabel
        }
        $systemURL = "https://$bucketName.s3.amazonaws.com/$systemLabel/$systemLabel.html"
        
        if ($systemName -match "") {
            $systemName = $systemLabel
        }

        $starSystemObj = [PSCustomObject]@{
            "SystemName" = $systemName
            "SystemDesignation" = $systemDesignation
            "XCoord" = (($systemCoords) -split ",")[0]
            "YCoord" = (($systemCoords) -split ",")[1]
            "StarColour" = $starType[0]
            "StarMass" = $starMass
            "Planets" = $planetBool
            "Habitable" = $habitableBool
            "AsteroidField" = $asteroidFieldBool[1]
            "SystemURL" = $systemUrl
        }
        if ($habitableBool) {
            $starSystemObj | Add-Member -Type NoteProperty -Name HabitableCount -Value $($asteroidFieldBool[2])
            $starSystemObj | Add-Member -Type NoteProperty -Name Hydrosphere -Value $($asteroidFieldBool[3])
        }
        $systemsArray.Add($starSystemObj)
    }
}

# Draw the master map gridlines
$gridPen = New-Object System.Drawing.Pen DarkSlateGray
$masterMapGraphics.DrawLine($gridPen,0,0,0,$masterMapSizeX)
$masterMapGraphics.DrawLine($gridPen,0,0,$masterMapSizeY,0)

foreach ($xGridLine in 2..$gridDividers) {
    if ($xGridLine -eq 2) {
        $linePosIterationX = 1+$gridDividerPixels
        $masterMapGraphics.DrawLine($gridPen,$linePosIterationX,0,$linePosIterationX,$masterMapSizeX)
    }
    $linePosIterationX = $linePosIterationX+$gridDividerPixels
    $masterMapGraphics.DrawLine($gridPen,$linePosIterationX,0,$linePosIterationX,$masterMapSizeX)
}

foreach ($yGridline in 2..$gridDividers) {
    if ($yGridline -eq 2) {
        $linePosIterationY = 1+$gridDividerPixels
        $masterMapGraphics.DrawLine($gridPen,0,$linePosIterationY,$masterMapSizeY,$linePosIterationY)
    }
    $linePosIterationY = $linePosIterationY+$gridDividerPixels
    $masterMapGraphics.DrawLine($gridPen,0,$linePosIterationY,$masterMapSizeY,$linePosIterationY)
}

# Draw the master map label
$sectorName = "Sector: $sectorNumber"
$masterMapGraphics.DrawString($sectorName,$fontMapNum,$masterMapBrushTitle,10,10)
$masterMapGraphics.DrawString("Scale: 1 square = 1 lt-mo",$fontMapNum,$masterMapBrushTitle,10,28)

# Fill the starmap with star system locations and set label locations
foreach ($systemObj in $systemsArray) {
    $brushFg = [System.Drawing.Brushes]::($systemObj.StarColour)
    $starColour = [System.Drawing.Color]::($systemObj.StarColour)
    $labelWidth = $($systemObj.SystemName).length * 5 + 4
    [int]$xPos = $systemObj.XCoord
    [int]$yPos = $systemObj.YCoord
    $masterMapBmp.SetPixel($xPos,$yPos,$starColour)
    if (($xPos+$labelWidth) -ge $masterMapSizeX) {
        $xTextPos = ($xPos-($labelWidth))
        $yTextPos = $yPos
    } else {
        $xTextPos = $xPos
    }
    if (($yTextPos+6) -ge $masterMapSizeY) {
        $yTextPos = ($yPos-$buffer)
    } else {
        $yTextPos = $yPos
    }
    if (($yPos) -le 6) {
        $yTextPos = ($yPos+$buffer)
    } else {
        $yTextPos = $yPos
    }
    [string]$graphicsText = $systemObj.SystemName
    [int]$xTextPos = $xTextPos+1
    [int]$yTextPos = $yTextPos-6
    $masterMapGraphics.DrawString($graphicsText,$fontStarNum,$brushFg,$xTextPos,$yTextPos)
}

$masterMapGraphics.Dispose()
$masterMapBmp.Save("$systemsPath\$masterMapFileName")

$systemsArray | ConvertTo-Json | Out-File -FilePath "$systemsPath\StarSystems.json"

Start-Process "$systemsPath\$masterMapFileName"

# Upload everything to Kanka
if ($uploadToKanka) {

    $headers = @{
        'Authorization'="Bearer $kankaPANkey"
    }

    $mapBody = @{
        'name' = "$sectorName"
        'type'='Starmap'
        'center_x'="$($masterMapSizeX/2)"
        'center_y'="$($masterMapSizeY/2)"
    } | ConvertTo-Json

    $kankaMapEntityID = ((Invoke-RestMethod -Uri "$kankaCampaignURL/entities" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data  | where {$_.name -match "$sectorName"}).id

    $kankaCheckMap = ($kankaMapEntityID -ge 1)

    if (!($kankaCheckMap)) {
        Invoke-RestMethod -Uri "$kankaCampaignURL/maps" -Method POST -Headers $headers -UseBasicParsing -ContentType "application/json" -Body $mapBody
    }
    
    $mapFilePath = "$systemsPath\$masterMapFileName"
    $client = New-Object System.Net.Http.HttpClient
    $client.DefaultRequestHeaders.Authorization = New-Object System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", $kankaPANkey)
    $fileBytes = [System.IO.File]::ReadAllBytes($mapFilePath)

    if ($fileBytes) {
        $stream = New-Object System.IO.MemoryStream
        $stream.Write($fileBytes, 0, $fileBytes.Length)
        $stream.Seek(0, 'Begin')

        $fileContent = New-Object System.Net.Http.StreamContent -ArgumentList $stream
        $fileContent.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse("application/octet-stream")
    
        $formData = New-Object System.Net.Http.MultipartFormDataContent
        $formData.Add($fileContent, "image", (Split-Path $mapFilePath -Leaf))
    
        $response = $client.PostAsync("$kankaCampaignURL/entities/$kankaMapEntityID/image", $formData).Result
    } else {
        Write-Host "Failed to read file: $mapFilePath"
    }
    
    $kankaMapID = ((Invoke-RestMethod -Uri "$kankaCampaignURL/maps" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data  | where {$_.name -match "$sectorName"}).id

    $sleepTime = 3

    foreach ($system in $systemsArray) {
        $location = @{
                "name" = $($system.SystemName)
                "type"= $($system.SystemURL)
                "is_private" = $false
        } | ConvertTo-Json
        $locationEntityID = (Invoke-RestMethod -Uri "$kankaCampaignURL/locations" -Method POST -Headers $headers -UseBasicParsing -ContentType "application/json" -Body $location).data.id
        $colour = [drawing.color]"$($system.StarColour)"
        $colourARGB = "0x"+"{0:x}" -f $colour.ToArgb()
        $hexColor = '#' + ($colourARGB -band 0xFFFFFF).ToString('X6')
        $marker = @{
                "name" = $($system.SystemName)
                "map_id"= $kankaMapID
                "latitude" = $($system.XCoord)
                "longitude" = $($system.YCoord)
                "shape_id" = 1
                "icon" = 1
                "visibility_id" = 1
                "colour" = $hexColor
                "font_colour" = $hexColor
                "size_id" = 1
                "circle_radius" = 1
                "entity_id" = $locationEntityID
                "entry" = $($system.SystemURL)
        } | ConvertTo-Json
        Invoke-RestMethod -Uri "$kankaCampaignURL/maps/$kankaMapID/map_markers" -Method POST -Headers $headers -UseBasicParsing -ContentType "application/json" -Body $marker
        Start-Sleep -Seconds $sleepTime
        Write-Host "Sleeping to prevent reaching API limits" -BackgroundColor Yellow -ForegroundColor Black
    }
}



<#
foreach ($system in $systemsArray) {
    switch ($system.StarColour) {
        "Red" {$terrestrialChance = 

<#
$sourceRec= [System.Drawing.Rectangle]::New(0,0,1000,1000)
$sectorMapCopy = $starmapBmp.Clone($sourceRec, $starmapBmp.PixelFormat)
$sectorMap = [System.Drawing.Bitmap]::new(1000,1000)
$pasteArea = [System.Drawing.Rectangle]::New(1,1,1000,1000)

To Do:

Create the sector maps
Detailed star system generation using StarGen
Pulling details from StarGen HTML to populate SystemArray
Inserting asteroid belts into SystemArray
Uploading HTML files to S3 bucket
Adding links to system details HTML to SystemArray


    #$asteroidFieldLoc = $(Get-Random $(($planetOrbits.Count)-1))
    $asteroidFieldLocText = "Asteroid belt between the orbit of planets $asteroidFieldLoc and $($asteroidFieldLoc+1)`n"



#>




<# All the S3 and Kanka API stuff all working
if ((Get-S3Object -BucketName "$bucketName" -Region us-east-1 -ProfileName MathewWeissProfile).key -notmatch $starmapFileName) {
    Write-S3Object -BucketName "$bucketName" -File "$systemsPath\$starmapFileName" -PublicReadOnly -Region us-east-1 -ProfileName rpg-stuff-profile
}

$accessToken = Get-Content G:\KankaPAN.txt

$header = @{
    Authorization="Bearer $accessToken"
}

$mapName = "Messier 13 Galactic Cluster Starmap"

$body = @{
    name=$mapName
    image_url="https://$bucketName.s3.amazonaws.com/Messier13Starmap.jpg"
}

if ((Invoke-RestMethod -Uri "https://kanka.io/api/1.0/campaigns/111078/maps" -Headers $header -Method Get).Data.Name -notmatch $mapName) {
    Invoke-RestMethod -Uri "https://kanka.io/api/1.0/campaigns/111078/maps" -Headers $header -Method Post -Body $body
}




$parameters = @{
    DBInstanceIdentifier = 'starsystems'
    Engine = 'mysql'
    DBInstanceClass = 'db.t3.micro'
    MasterUsername = 'admin'
    MasterUserPassword = $(Get-Content G:\dynamoDBAdminPW.txt) ## Do not to include a forward slash, @ symbol, double quotes or spaces
    AllocatedStorage = 20 ## Gigabytes
    PubliclyAccessible = $true ## to connect over the Internet
}
$instance = New-RDSDBInstance @parameters -ProfileName rpg-stuff-profile -Region us-east-1

#>




