# Space RP Game World Generator v3
# Starts by generating random systems with stellar map coordinates, if the system is habitable or not, if the system has a habitable planet with cities, a starbase, an asteroid base, or a base on an uninhabitable planet

Import-Module AWSPowershell

Add-Type -AssemblyName System.Drawing

# Get the home directory for the script
$homePath = "G:\Colonial_Alliance_Game"

# Set the locations of required software and filepaths for the script to operate
$WorldScriptPath = "$homePath\game-world-generator\powershell-version\generate-game-world"
$SoftwarePath = "$homePath\StarmapCreation\Software"
$htmlFiles = "$SoftwarePath\StarGen\html"
$stargenPath = "$SoftwarePath\StarGen\StarGen.exe"
$planetgenPath = "$SoftwarePath\Planets\planet.exe"
$systemsPath = "$homePath\StarmapCreation\StarSystems"
$refFilesDir = "$SoftwarePath\StarGen\ref"

# Reset the world generation. Deletes all systems created
$doGeneration = $true

# Define the main starmap properties
$systemCount = 70 # star systems per map (sector) # Standard 5000
$systemCountVariation = 15 # how much to randomly vary the number or and down from system count
$sectorNumber = "2" # What sector of space is this, purely for labelling the map
$gridDividers = 12 # How many grid lines to have on the map
$gridDividerPixels = 100 # How many pixels between each grid line
$buffer = 5 # Pixel buffer around the edges of the map image

# Kanka details
$uploadToKanka = $true
$kankaCampaignURL = "https://kanka.io/api/1.0/campaigns/111078"
$kankaPANPath = "$homePath\kankaPANKey.txt"

# AWS details
$uploadToAWS = $true
$bucketName = "rpg-objects"
$awsProfileName = "rpg-stuff-profile"

################ END OF CUSTOMISABLE VARIABLES ################

if (!(Test-Path $WorldScriptPath)) {Write-Host "generate-game-world folder not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $SoftwarePath)) {Write-Host "Software folder not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $htmlFiles)) {Write-Host "StarGen HTML folder not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $stargenPath)) {Write-Host "StarGen executable not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $planetgenPath)) {Write-Host "Planet Generator executable not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $systemsPath)) {Write-Host "Location where to output created star systems files not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if (!(Test-Path $refFilesDir)) {Write-Host "reference files StarGen uses in its HTML files not detected or defined correctly" -BackgroundColor Red -ErrorAction Stop}
if ($uploadToKanka -eq $true -and $kankaCampaignURL -eq "") {Write-Host "Kanka campaign URL missing" -BackgroundColor Red -ErrorAction Stop}
if ($uploadToAWS -eq $true -and $bucketName -eq "") {Write-Host "S3 Bucket name missing" -BackgroundColor Red -ErrorAction Stop}

# colour values for the biomes where we can put settlements created on the planet maps generated by planet.exe
$okBiomes = "210210210","250215165","105155120","220195175","225155100","155215170","170195200","185150160","130190025","110160170"# Tundra, Grasslands, Taiga, Desert, Savanna, Temperate Forest, Temperate Rainforest, Xeric Shrubland and Dry Forest, Tropical Dry Forest, Tropical Rainforest

# Names to use when naming star systems which are claimed
[System.Collections.ArrayList]$systemNames = "Nexus,Neotopia,Aeloria,Aetheria,Albion,Alexandria,Amaterasu,Amsterdam,Andromeda,Angkor,Antares,Araucaria,Arcadia,Artemis,Asgard,Athens,Atlantis,Aurielle,Avalon,Azurite,Babylon,Bali,Bangkok,Barcelona,Beijing,Berlin,Bharat,Brittanica,Byzantium,Caelum,Cairo,Calypso,Camelot,Caprica,Carthage,Casablanca,Caspia,Ceres,Ceylon,Chandra,Chichen Itza,Chimera,Chiron,Colossus,Copenhagen,Cordoba,Cyberion,Dalarna,Dantooine,Delphi,Dravida,Dubai,Dublin,Echelon,Edenia,Edinburgh,El Dorado,Elysium,Eridanus,Esperia,Euphoria,Galaxia,Gilead,Gilead,Hades,Halcyon,Hanoi,Helios,Helsinki,Hiroshima,Hy Brasil,Hyperborea,Hyperion,Icaria,Inca,Isfahan,Isla Nublar,Istanbul,Jakarta,Jerusalem,Jovia,Kaida,Kemet,Kepler,Krynn,Krypton,Kuala Lumpur,Kyoto,Lemuria,London,Los Angeles,Lumina,Luminar,Luminelle,Machu Picchu,Magellan,Mahabharata,Manila,Melbourne,Meridian,Mjolnir,Moscow,Mumbai,Mumbai,Nagasaki,Narnia,Neo-Tokyo,Neuheim,New York,Nibiru,Nirvana,Novamira,Oberon,Odyssey,Olympus,Omicron,Orinoco,Orion,Osaka,Oslo,Oz,Pandemonium,Pandora,Pangea,Paris,Penglai,Persepolis,Perseus,Petra,Phnom Penh,Phoenix,Polaris,Pompeii,Prometheus,Pythia,Rapa Nui,Regalia,Rhapsody,Rigel,Rio de Janeiro,Rome,Sagittarius,Sakurano,Samarkand,Seoul,Serenity,Shambhala,Shanghai,Shangri-La,Singapore,Siren,Solitude,Solstice,Sputnik,Stardust,Stockholm,Stratos,Sydney,Tabriz,Taipei,Talaria,Tartarus,Tel Aviv,Terra Nova,Tesseract,Thalassa,Themyscira,Thule,Tikal,Titan,Tokyo,Transcendence,Utopia,Valhalla,Vega,Vesperia,Vienna,Vulcan,Wakanda,Xanadu,Xenon,Yggdrasil,Zhulong,Zion,Zora" -split ','
[int]$masterMapSizeX = $gridDividers*$gridDividerPixels+2 # map file pixel width
[int]$masterMapSizeY = $masterMapSizeX # map file pixel heigh
$masterMapBmp = new-object System.Drawing.Bitmap $masterMapSizeX,$masterMapSizeY
$masterMapBrushBg = [System.Drawing.Brushes]::Black
$fontMapNum = new-object System.Drawing.Font "Lucida Sans",8
$fontStarNum = new-object System.Drawing.Font "Lucida Sans",7
$masterMapGraphics = [System.Drawing.Graphics]::FromImage($masterMapBmp)
$masterMapGraphics.FillRectangle($masterMapBrushBg,0,0,$masterMapBmp.Width,$masterMapBmp.Height)
$masterMapBrushTitle = [System.Drawing.Brushes]::White
$masterMapFileName = "Sector_$sectorNumber`_Starmap.jpg"

# Gets AWS credentials
$awsCreds = Get-AWSCredential -ProfileName $awsProfileName

# Uploading StarGen reference files to the bucket
if ($uploadToAWS) {
    $refFiles = Get-ChildItem $refFilesDir/*
    $refCheck = ((Get-S3Object -BucketName "$bucketName" -Credential $awsCreds | where {$_.Key -match "ref"}).count) -ge 0
    if (!$refCheck) {
        foreach ($refFile in $refFiles) {
            $refFilePath = Join-Path $refFile.Directory $refFile.Name
            $refFilePath
            Write-S3Object -BucketName "$bucketName/ref" -Credential $awsCreds -PublicReadOnly -File $refFilePath
        }
    }
}

# Clears all the world data created
if ($doGeneration) {
    Remove-Item -Path "$systemsPath\*" -Recurse -Force
    Remove-Item -Path "$htmlFiles\*" -Recurse -Force
    Copy-Item -Path $refFilesDir -Destination $systemsPath -Recurse
}

# Attempts to represent reasonably accurate real world chances of star type, they're in order of star colour, lower mass range, upper mass range, chance of planets, chance of habitable planets.
function Get-StarType {
    $rnd = Get-Random -Minimum 1 -Maximum 1000000
    switch ($rnd) {
        {$_ -ge 1 -and $_ -le 3} {"Blue",$(Get-Random -Minimum 3 -Maximum 150),0,0}
        {$_ -ge 4 -and $_ -le 1400} {"LightSkyBlue",3,70,0,0}
        {$_ -ge 1401 -and $_ -le 7700} {"White",0.15,1.2,0,0}
        {$_ -ge 7701 -and $_ -le 29000} {"LightYellow",0.9,1.2,80,5}
        {$_ -ge 29001 -and $_ -le 106000} {"Yellow",0.9,1.2,95,40}
        {$_ -ge 106001 -and $_ -le 235500} {"Orange",0.5,0.8,80,0}
        {$_ -ge 235501 -and $_ -le 1000000} {"Red",0.075,0.4,70,0}
    }
}

function Get-StarLocation {
    $labelX = 0..140
    $labelY = 0..48
    do {
        $1 = Get-Random -Minimum 5 -Maximum ($masterMapSizeX-5)
        $2 = Get-Random -Minimum 5 -Maximum ($masterMapSizeY-5)
        $coords = "$1,$2"
    } until ($systemsCoordArray -notcontains $coords -and ($1 -notin $labelX -or $2 -notin $labelY))
    $systemsCoordArray += "$1,$2"
    return $coords
}

function Get-PlanetaryUninhabitableSystem {
param($StarMass,$StarName)
Set-Location ($stargenPath | Split-Path)
    do {
        Start-Process $stargenPath -ArgumentList "-m$StarMass -M -g" -Wait -NoNewWindow
        Start-Sleep -Seconds 1
        $starFile = (Get-ChildItem $htmlFiles -Filter "*.html").FullName | Sort-Object -Property LastWriteTime | Select-Object -Last 1
        $starFileTerresCheck = (Get-Content $starFile -Raw) -match "Terrestrial"
        if ($starFileTerresCheck -eq $true) {
            Remove-Item "$htmlFiles\*" -Force
        }
    } until ($starFile -ne $null -and $starFileTerresCheck -eq $false)
    $html = Get-Content $starFile -Raw
    $htmlWeb = Invoke-WebRequest -Uri $starfile -UseBasicParsing
    $asteroidBool = ($html | Select-String -Pattern "Asteroids.gif" -AllMatches).matches.count -ge 1
    $currentSeed = (($html -split "`n" | Select-String -Pattern "System *") -split ">" -split "-" -split " " -split "<")[3]
    $currentName = "System $currentSeed - StarGen.exe $currentSeed-$StarMass"
    $currentFileLink = "StarGen.exe $currentSeed-$StarMass"
    $currentFileName = "StarGen.exe-$currentSeed-$StarMass"
    $html = $html -replace $currentName,$StarName
    $html = $html -replace $currentFileName,$StarName
    $html = $html -replace $currentFileLink,$StarName
    $htmlObj = New-Object -Com "HTMLFile"
    $htmlObj.IHTMLDocument2_write($htmlWeb.RawContent)
    Set-Content "$htmlFiles\$StarName.html" $html
    New-Item -Path $systemsPath -ItemType Directory -Name $StarName
    Move-Item -Path "$htmlFiles\$StarName.html" -Destination $systemsPath\$StarName
    if ($uploadToAWS) {
        Write-S3Object -BucketName "$bucketName/$StarName" -Credential $awsCreds -File "$systemsPath\$StarName\$StarName.html" -PublicReadOnly
    }
    $asteroidBool
}

function Get-HabitableSystem {
param($StarMass,$StarName)
Set-Location ($stargenPath | Split-Path)
    do {
        Start-Process $stargenPath -ArgumentList "-m$StarMass -M -g" -Wait -NoNewWindow
        Start-Sleep -Seconds 1
        $starFile = (Get-ChildItem $htmlFiles -Filter "*.html").FullName | Sort-Object -Property LastWriteTime | Select-Object -Last 1
        $starFileTerresCheck = (Get-Content $starFile -Raw) -match "Terrestrial"
        if ($starFileTerresCheck -ne $true) {
            Remove-Item "$htmlFiles\*" -Force
        }
    } until ($null -ne $starFile -and $starFileTerresCheck -eq $true)
    $html = Get-Content $starFile -Raw
    $htmlWeb = Invoke-WebRequest -Uri $starfile -UseBasicParsing
    $hydrospheres = @(($html -split "`n" | Select-String -Pattern "Hydrosphere") -replace "<TR>","" -replace "<TH>","" -replace "</TR>","" -replace "</TH>","" -replace "<TD>","" -replace "</TD>","" -replace "Hydrosphere percentage","" | where {$_ -notmatch "0.0"}) -split "`n"
    $terresCount = ($html -split "<" | Select-String -Pattern "TerrestrialPlanet.gif" | Group-Object).count
    $asteroidBool = ($html | Select-String -Pattern "Asteroids.gif" -AllMatches).matches.count -ge 1
    $currentSeed = (($html -split "`n" | Select-String -Pattern "System *") -split ">" -split "-" -split " " -split "<")[3]
    $currentName = "System $currentSeed - StarGen.exe $currentSeed-$StarMass"
    $currentFileLink = "StarGen.exe $currentSeed-$StarMass"
    $currentFileName = "StarGen.exe-$currentSeed-$StarMass"
    $html = $html -replace $currentName,$StarName
    $html = $html -replace $currentFileName,$StarName
    $html = $html -replace $currentFileLink,$StarName
    $htmlObj = New-Object -Com "HTMLFile"
    $htmlObj.IHTMLDocument2_write($htmlWeb.RawContent)
    Set-Content "$htmlFiles\$StarName.html" $html
    New-Item -Path $systemsPath -ItemType Directory -Name $StarName
    Move-Item -Path "$htmlFiles\$StarName.html" -Destination $systemsPath\$StarName
    if ($uploadToAWS) {
        Write-S3Object -BucketName "bucketName/$StarName" -Credential $awsCreds -File "$systemsPath\$StarName\$StarName.html" -PublicReadOnly
    }
    $asteroidBool,$terresCount,$hydrospheres
}

# Generate star system base values
$systemsCoordArray = @()
$systemsArray = New-Object System.Collections.Generic.List[psobject]

if ($doGeneration) {
    $systemCountFinal = Get-Random -Minimum ($systemCount-$systemCountVariation) -Maximum ($systemCount+$systemCountVariation)
    foreach ($systemCount in 1..$systemCountFinal) {
        $starType = Get-StarType
        do {
            $systemCoords = Get-StarLocation
            if ($systemsCoordArray -contains $systemCoords) {
                Write-Host "Duplicate coordinates found, retrying" -BackgroundColor Red
            }
        } until ($systemsCoordArray -notcontains $systemCoords)
        $systemsCoordArray += "$systemCoords"
        [string]$systemNum = $($systemCoords) -replace ","
        $systemDesignation = "System_$systemNum"
        $starMass = Get-Random -Minimum $starType[1] -Maximum $starType[2]
        $planetBool = ((Get-Random -Minimum 0 -Maximum 100) -in 0..($starType[3]))
        if ($planetBool) {$habitableBool = ((Get-Random -Minimum 0 -Maximum 100) -in 0..($starType[4]))} else {$habitableBool = $false}
        if ($habitableBool -eq $True) {
            $systemLabel = ($sectorNumber+"_"+('{0:d4}' -f $systemCount))+"_"+(Get-Random -InputObject $systemNames)
            $systemNames.Remove($systemLabel)
        } else {
            $systemLabel = $sectorNumber+"_"+('{0:d4}' -f $systemCount)
        }
        if (!$planetBool) {
            Write-Host "Generating non-planetary system $systemLabel with stellar mass of $starMass"
            $asteroidFieldBool = (Get-Random -Minimum 0 -Maximum 100) -in 0..12
        }
        if ($planetBool -eq $true -and $habitableBool -eq $true) {
            Write-Host "Generating inhabitable system $systemLabel with stellar mass of $starMass"
            $inhabitablePlanetReturn = Get-HabitableSystem -StarMass $starMass -StarName $systemLabel
            $asteroidFieldBool = $inhabitablePlanetReturn[0]
        }
        if ($planetBool -eq $true -and $habitableBool -eq $false) {
            Write-Host "Generating uninhabitable system $systemLabel with stellar mass of $starMass"
            $asteroidFieldBool = Get-PlanetaryUninhabitableSystem -StarMass $starMass -StarName $systemLabel
        }
        $systemURL = "https://$bucketName.s3.amazonaws.com/$systemLabel/$systemLabel.html"
            
        $starSystemObj = [PSCustomObject]@{
            "SystemName" = $systemLabel
            "SystemDesignation" = $systemDesignation
            "XCoord" = (($systemCoords) -split ",")[0]
            "YCoord" = (($systemCoords) -split ",")[1]
            "StarColour" = $starType[0]
            "StarMass" = $starMass
            "Planets" = $planetBool
            "Habitable" = $habitableBool
            "AsteroidField" = $asteroidFieldBool
            "SystemURL" = $systemUrl
        }
        $systemsArray.Add($starSystemObj)
    }
}

# Draw the master map gridlines
$gridPen = New-Object System.Drawing.Pen DarkSlateGray
$masterMapGraphics.DrawLine($gridPen,0,0,0,$masterMapSizeX)
$masterMapGraphics.DrawLine($gridPen,0,0,$masterMapSizeY,0)

foreach ($xGridLine in 2..$gridDividers) {
    if ($xGridLine -eq 2) {
        $linePosIterationX = 1+$gridDividerPixels
        $masterMapGraphics.DrawLine($gridPen,$linePosIterationX,0,$linePosIterationX,$masterMapSizeX)
    }
    $linePosIterationX = $linePosIterationX+$gridDividerPixels
    $masterMapGraphics.DrawLine($gridPen,$linePosIterationX,0,$linePosIterationX,$masterMapSizeX)
}

foreach ($yGridline in 2..$gridDividers) {
    if ($yGridline -eq 2) {
        $linePosIterationY = 1+$gridDividerPixels
        $masterMapGraphics.DrawLine($gridPen,0,$linePosIterationY,$masterMapSizeY,$linePosIterationY)
    }
    $linePosIterationY = $linePosIterationY+$gridDividerPixels
    $masterMapGraphics.DrawLine($gridPen,0,$linePosIterationY,$masterMapSizeY,$linePosIterationY)
}

# Draw the master map label
$sectorName = "Sector: $sectorNumber"
$masterMapGraphics.DrawString($sectorName,$fontMapNum,$masterMapBrushTitle,10,10)
$masterMapGraphics.DrawString("Scale: 1 square = 1 lt-mo",$fontMapNum,$masterMapBrushTitle,10,28)

# Fill the starmap with star system locations and set label locations
foreach ($systemObj in $systemsArray) {
    $brushFg = [System.Drawing.Brushes]::($systemObj.StarColour)
    $starColour = [System.Drawing.Color]::($systemObj.StarColour)
    $labelWidth = $($systemObj.SystemName).length * 5 + 4
    [int]$xPos = $systemObj.XCoord
    [int]$yPos = $systemObj.YCoord
    $masterMapBmp.SetPixel($xPos,$yPos,$starColour)
    if (($xPos+$labelWidth) -ge $masterMapSizeX) {
        $xTextPos = ($xPos-($labelWidth))
        $yTextPos = $yPos
    } else {
        $xTextPos = $xPos
    }
    if (($yTextPos+6) -ge $masterMapSizeY) {
        $yTextPos = ($yPos-$buffer)
    } else {
        $yTextPos = $yPos
    }
    if (($yPos) -le 6) {
        $yTextPos = ($yPos+$buffer)
    } else {
        $yTextPos = $yPos
    }
    [string]$graphicsText = $systemObj.SystemName
    [int]$xTextPos = $xTextPos+1
    [int]$yTextPos = $yTextPos-6
    $masterMapGraphics.DrawString($graphicsText,$fontStarNum,$brushFg,$xTextPos,$yTextPos)
}

$masterMapGraphics.Dispose()
$masterMapBmp.Save("$systemsPath\$masterMapFileName")

$systemsArray | ConvertTo-Json | Out-File -FilePath "$systemsPath\StarSystems.json"

Start-Process "$systemsPath\$masterMapFileName"

# Upload everything to Kanka
if ($uploadToKanka) {
    $kankaPANkey = Get-Content $kankaPANPath

    $headers = @{
        'Authorization'="Bearer $kankaPANkey"
    }

    $mapBody = @{
        'name' = "$sectorName"
        'type'='Starmap'
        'center_x'="$($masterMapSizeX/2)"
        'center_y'="$($masterMapSizeY/2)"
    } | ConvertTo-Json

    $kankaCheckMap = (((Invoke-RestMethod -Uri "$kankaCampaignURL/entities" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data  | where {$_.name -match "$sectorName"}).id -ge 1)

    if (!($kankaCheckMap)) {
        Invoke-RestMethod -Uri "$kankaCampaignURL/maps" -Method POST -Headers $headers -UseBasicParsing -ContentType "application/json" -Body $mapBody
    }

    $kankaMapEntityID = ((Invoke-RestMethod -Uri "$kankaCampaignURL/entities" -Method GET -Headers $headers -UseBasicParsing -ContentType "application/json").data  | where {$_.name -match "$sectorName"}).id

    $mapFilePath = "$systemsPath\$masterMapFileName"
    
    # still broken
    $entityBody = @{
        'image'="$(Get-Item -Path $mapFilePath)"
    } | ConvertTo-Json

    # still broken
    Invoke-WebRequest -Uri "$kankaCampaignURL/entities/$kankaMapEntityID/image" -Method POST -Headers $headers -InFile $mapFilePath
}



<#
foreach ($system in $systemsArray) {
    switch ($system.StarColour) {
        "Red" {$terrestrialChance = 

<#
$sourceRec= [System.Drawing.Rectangle]::New(0,0,1000,1000)
$sectorMapCopy = $starmapBmp.Clone($sourceRec, $starmapBmp.PixelFormat)
$sectorMap = [System.Drawing.Bitmap]::new(1000,1000)
$pasteArea = [System.Drawing.Rectangle]::New(1,1,1000,1000)

To Do:

Create the sector maps
Detailed star system generation using StarGen
Pulling details from StarGen HTML to populate SystemArray
Inserting asteroid belts into SystemArray
Uploading HTML files to S3 bucket
Adding links to system details HTML to SystemArray


    #$asteroidFieldLoc = $(Get-Random $(($planetOrbits.Count)-1))
    $asteroidFieldLocText = "Asteroid belt between the orbit of planets $asteroidFieldLoc and $($asteroidFieldLoc+1)`n"



#>




<# All the S3 and Kanka API stuff all working
if ((Get-S3Object -BucketName "$bucketName" -Region us-east-1 -ProfileName MathewWeissProfile).key -notmatch $starmapFileName) {
    Write-S3Object -BucketName "$bucketName" -File "$systemsPath\$starmapFileName" -PublicReadOnly -Region us-east-1 -ProfileName rpg-stuff-profile
}

$accessToken = Get-Content G:\KankaPAN.txt

$header = @{
    Authorization="Bearer $accessToken"
}

$mapName = "Messier 13 Galactic Cluster Starmap"

$body = @{
    name=$mapName
    image_url="https://$bucketName.s3.amazonaws.com/Messier13Starmap.jpg"
}

if ((Invoke-RestMethod -Uri "https://kanka.io/api/1.0/campaigns/111078/maps" -Headers $header -Method Get).Data.Name -notmatch $mapName) {
    Invoke-RestMethod -Uri "https://kanka.io/api/1.0/campaigns/111078/maps" -Headers $header -Method Post -Body $body
}




$parameters = @{
    DBInstanceIdentifier = 'starsystems'
    Engine = 'mysql'
    DBInstanceClass = 'db.t3.micro'
    MasterUsername = 'admin'
    MasterUserPassword = $(Get-Content G:\dynamoDBAdminPW.txt) ## Do not to include a forward slash, @ symbol, double quotes or spaces
    AllocatedStorage = 20 ## Gigabytes
    PubliclyAccessible = $true ## to connect over the Internet
}
$instance = New-RDSDBInstance @parameters -ProfileName rpg-stuff-profile -Region us-east-1

#>


